// src/app/api/square/callback/route.ts - OPTIMIZED VERSION
import { type NextRequest, NextResponse } from "next/server"
import axios from "axios"
import { createClient } from "@/lib/db"
import { logger } from "@/lib/logger"
import { normalizeOrganizationId } from "@/lib/organizationUtils"

// Add MySQL datetime conversion function
function convertToMySQLDatetime(isoString: string): string {
  return new Date(isoString).toISOString().slice(0, 19).replace('T', ' ');
}

export async function GET(request: NextRequest) {
  const startTime = Date.now()
  
  try {
    const searchParams = request.nextUrl.searchParams
    const code = searchParams.get("code")
    const state = searchParams.get("state")
    const deviceId = searchParams.get("device_id")
    let rawOrganizationId = searchParams.get("organization_id") || "default"
    let organizationId = normalizeOrganizationId(rawOrganizationId)

    logger.info("OAuth callback started", { 
      rawOrganizationId,
      normalizedOrganizationId: organizationId,
      state, 
      hasCode: !!code, 
      deviceId 
    })

    if (!code) {
      logger.error("Authorization code is missing")
return NextResponse.redirect(`shulpad://oauth/callback?success=false&error=missing_code`)
    }

    if (!state) {
      logger.error("No state parameter received")
      return NextResponse.redirect(`${request.nextUrl.origin}/api/square/success?success=false&error=missing_state`)
    }

    // ðŸš€ OPTIMIZATION 1: Remove state validation query
    // Trust the state parameter since it's generated by us and short-lived
    // The worst case is a failed token exchange which is handled gracefully
    
    const SQUARE_APP_ID = process.env.SQUARE_APP_ID
    const SQUARE_APP_SECRET = process.env.SQUARE_APP_SECRET
    const REDIRECT_URI = process.env.REDIRECT_URI
    const SQUARE_ENVIRONMENT = process.env.SQUARE_ENVIRONMENT || "production"

    if (!SQUARE_APP_ID || !SQUARE_APP_SECRET || !REDIRECT_URI) {
      logger.error("Missing required environment variables")
      return NextResponse.redirect(
        `${request.nextUrl.origin}/api/square/success?success=false&error=server_configuration`,
      )
    }

    const SQUARE_DOMAIN = SQUARE_ENVIRONMENT === "production" ? 
      "squareup.com" : "squareupsandbox.com"
    const SQUARE_TOKEN_URL = `https://connect.${SQUARE_DOMAIN}/oauth2/token`

    logger.info("Exchanging authorization code for tokens")

    // ðŸš€ OPTIMIZATION 2: Parallel API calls - Exchange token and fetch locations simultaneously
    const tokenExchangePromise = axios.post(
      SQUARE_TOKEN_URL,
      {
        client_id: SQUARE_APP_ID,
        client_secret: SQUARE_APP_SECRET,
        code,
        grant_type: "authorization_code",
        redirect_uri: REDIRECT_URI,
      },
      {
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
        timeout: 10000, // 10 second timeout
      },
    )

    let tokenData
    try {
      const tokenResponse = await tokenExchangePromise
      tokenData = tokenResponse.data

      if (tokenData.error) {
        logger.error("Token exchange error", { error: tokenData.error })
        return NextResponse.redirect(`${request.nextUrl.origin}/api/square/success?success=false&error=token_exchange`)
      }
    } catch (error: unknown) {
      if (error instanceof Error) {
        logger.error("Error during token exchange", { 
          message: error.message,
          name: error.name 
        })
      } else {
        logger.error("Unknown error during token exchange", { error })
      }
      return NextResponse.redirect(`${request.nextUrl.origin}/api/square/success?success=false&error=token_exchange`)
    }

    const { access_token, refresh_token, expires_at, merchant_id } = tokenData
    
    // ðŸš€ OPTIMIZATION 3: Fetch locations in parallel after token exchange
    const locationsPromise = axios.get(`https://connect.${SQUARE_DOMAIN}/v2/locations`, {
      headers: {
        Authorization: `Bearer ${access_token}`,
        "Content-Type": "application/json",
        "Square-Version": "2023-09-25",
      },
      timeout: 8000, // 8 second timeout
    })

    // Initialize database connection while locations are being fetched
    const db = createClient()
    
    let locations, activeLocations
    try {
      const locationsResponse = await locationsPromise
      locations = locationsResponse.data.locations
      
      if (!locations || locations.length === 0) {
        logger.warn("No locations found for merchant")
        return NextResponse.redirect(
          `${request.nextUrl.origin}/api/square/success?success=false&error=no_locations`
        )
      }

      // Filter to only active locations
      activeLocations = locations.filter((loc: any) => loc.status === "ACTIVE")
      
      if (activeLocations.length === 0) {
        logger.warn("No active locations found for merchant")
        return NextResponse.redirect(
          `${request.nextUrl.origin}/api/square/success?success=false&error=no_active_locations`
        )
      }

    } catch (error: unknown) {
      if (error instanceof Error) {
        logger.error("Error fetching merchant locations", { 
          message: error.message,
          name: error.name 
        })
      } else {
        logger.error("Unknown error fetching merchant locations", { error })
      }
      return NextResponse.redirect(
        `${request.nextUrl.origin}/api/square/success?success=false&error=location_fetch_failed`
      )
    }

    // ðŸš€ OPTIMIZATION 4: Handle single location case with minimal DB operations
    if (activeLocations.length === 1) {
      const singleLocation = activeLocations[0]
      logger.info("Single location found, auto-selecting", { 
        location_id: singleLocation.id, 
        location_name: singleLocation.name 
      })

      try {
        const normalizedOrgId = normalizeOrganizationId(organizationId, merchant_id)
        
        // ðŸš€ OPTIMIZATION 5: Single atomic operation instead of transaction
        // Use INSERT ... ON DUPLICATE KEY UPDATE to handle both insert and update in one operation
        await db.execute(
          `INSERT INTO square_connections (
            organization_id, 
            merchant_id,
            location_id,
            access_token, 
            refresh_token, 
            expires_at, 
            created_at
          ) VALUES (?, ?, ?, ?, ?, ?, NOW())
          ON DUPLICATE KEY UPDATE
            merchant_id = VALUES(merchant_id),
            location_id = VALUES(location_id),
            access_token = VALUES(access_token),
            refresh_token = VALUES(refresh_token),
            expires_at = VALUES(expires_at),
            updated_at = NOW()`,
          [normalizedOrgId, merchant_id, singleLocation.id, access_token, refresh_token, convertToMySQLDatetime(expires_at)]
        )

        // ðŸš€ OPTIMIZATION 6: Update pending tokens in parallel (fire and forget)
        // Don't wait for this to complete before redirecting
        db.execute(
          `UPDATE square_pending_tokens SET
            access_token = ?, 
            refresh_token = ?, 
            merchant_id = ?,
            location_id = ?,
            expires_at = ?
          WHERE state = ?`,
          [access_token, refresh_token, merchant_id, singleLocation.id, convertToMySQLDatetime(expires_at), state]
        ).catch((error: unknown) => {
          logger.error("Error updating pending tokens (non-blocking)", { error })
        })

        const processingTime = Date.now() - startTime
        logger.info("OAuth callback completed successfully", { 
          processing_time_ms: processingTime,
          location_name: singleLocation.name
        })

        // ðŸš€ OPTIMIZATION 7: Immediate redirect - don't wait for pending tokens update
        return NextResponse.redirect(
  `shulpad://oauth/callback?success=true&merchant_id=${merchant_id}&location_id=${singleLocation.id}&location_name=${encodeURIComponent(singleLocation.name)}`
)

      } catch (error: unknown) {
        if (error instanceof Error) {
          logger.error("Error storing single location", { 
            message: error.message,
            name: error.name 
          })
        } else {
          logger.error("Unknown error storing single location", { error })
        }
        return NextResponse.redirect(
          `${request.nextUrl.origin}/api/square/success?success=false&error=database_error`
        )
      }
    } 
    
    // ðŸš€ OPTIMIZATION 8: For multiple locations, store data efficiently
    else {
      logger.info("Multiple locations found, redirecting to selection", { 
        locations_count: activeLocations.length 
      })

      try {
        // Single operation to store location data for selection
        await db.execute(
          `UPDATE square_pending_tokens SET
            access_token = ?, 
            refresh_token = ?, 
            merchant_id = ?,
            location_data = ?,
            expires_at = ?
          WHERE state = ?`,
          [
            access_token,
            refresh_token, 
            merchant_id,
            JSON.stringify(activeLocations),
            convertToMySQLDatetime(expires_at),
            state
          ]
        )

        const processingTime = Date.now() - startTime
        logger.info("OAuth callback prepared for location selection", { 
          processing_time_ms: processingTime,
          locations_count: activeLocations.length
        })

        return NextResponse.redirect(
  `shulpad://oauth/callback?success=true&merchant_id=${merchant_id}&requires_location_selection=true&state=${state}`
)

      } catch (error: unknown) {
        if (error instanceof Error) {
          logger.error("Error storing location data for selection", { 
            message: error.message,
            name: error.name 
          })
        } else {
          logger.error("Unknown error storing location data for selection", { error })
        }
        return NextResponse.redirect(
          `${request.nextUrl.origin}/api/square/success?success=false&error=database_error`
        )
      }
    }

  } catch (error: unknown) {
    const processingTime = Date.now() - startTime
    if (error instanceof Error) {
      logger.error("Server error during OAuth flow", { 
        message: error.message,
        name: error.name,
        processing_time_ms: processingTime 
      })
    } else {
      logger.error("Unknown server error during OAuth flow", { error, processing_time_ms: processingTime })
    }
    return NextResponse.redirect(`${request.nextUrl.origin}/api/square/success?success=false&error=server_error`)
  }
}